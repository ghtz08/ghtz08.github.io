---
layout: post
title:  "示例"
date:   2019-06-21 17:15:34 +0800
categories: [TLA+, Learn TLA+ 的翻译, 前言]
permalink: /tla/learntla/introduction/example
---

一般来说，模型检查的概念在理论上似乎很有吸引力，但人们常常怀疑它是否能在实践中使用。因此，这是一个指导示例，演示如何实现一个简单的规范（spec）并查找错误。**这个示例不是理解这个指南其它部分所必须的**。后面的章节将更广泛地介绍这里的所有内容。不过还是值得一试。

## 问题

你在为银行写软件。Alice 和 Bob 是你的客户，每个人的账户上都有一定数量的钱。Alice 想转钱给 Bob。你会怎么建模？假设你只关心他们的银行账户。

### 第一步

这是一种方式：

```tla+
---- MODULE transfer ----
EXTENDS Naturals, TLC

(* --algorithm transfer
variables alice_account = 10, bob_account = 10, money = 5;

begin
A: alice_account := alice_account - money;
B: bob_account := bob_account + money;

end algorithm *)
====
```

在我们捣鼓它之前，先分解一下当前的语法。由于 TLA+ 是一种规范（specification）语言，它对程序的结构有一些强制的限制。

- 如果文件名是 “transfer”，规范的第一行必须是 `---- MODULE transfer ----`。每边至少要有四个 `-`。类似的，最后一行必须要有四个 `=`。`MODULE` 之前，和四个 `====` 之后的任何内容都会被忽略。
- `EXTENDS` 等价于 `import` 语句。
- `\*` 是行注释，`(* *)` 是块注释。注意，这里是故意把这个算法放在注释块中。由于 PlusCal 算法在语法上不是有效的 TLA+ 程序，所以我们不能在 TLA 文件中运行它。而是你把算法放在注释中，让 PlusCal 翻译器来翻译它。
- ~~令人震惊的是~~ `variables` 是变量（`variables` is, shockingly enough, variables.）。请注意，在声明变量的时候我们使用 `=`，在算法里我们用 `:=` 表示赋值。在声明变量的其它地方 `=` 是比较运算符。不等于号是 `/=`。例如：`1 + 2 = 3; 2 + 3 /= 4`。
- `A:` 和 `B:` 都是标签。它们定义了算法所采取的步骤。理解标签的工作原理对于编写更复杂的算法至关重要，因为它们定义了并发可能会出现严重错误的地方。我们稍后会更深入地研究它们。

那么我们该怎么运行这个呢？嗯，我们无法运行。首先，这不是真正的代码，我们必须先转换它。而且我们不是完全“运行”它。而是我们来设计模型测试它。我们现在开始吧。

## TLA+ Toolbox

[TLA+ Toolbox](https://github.com/tlaplus/tlaplus/releases/latest) 是一个 TLA+ 的 IDE。TLA+ 有很多活动部件，因此不管你的偏好是什么，使用 IDE 都是正确的选择。

![启动界面](/tla/assets/introduction/intro_toolbox.png)

我们打开它并添加我们当前的项目。一个规范（specification）有两部分：模块和模型。模块有我们的代码，模型用来测试它们。用上面的代码创建一个新的规范（spec），然后翻译成 TLA+（在 Windows 中使用 Ctrl+T，在 Mac 中使用 ⌘+T）.

![转换后的代码界面](/tla/assets/introduction/translated.png)

很快，您将看到一堆代码出现。这就是我们 PlusCal 算法转换后的 TLA+ 代码，也就是模型检查器实际运行的内容。说到这里，我们还要创建一个模型：

![建好的新模型](/tla/assets/introduction/model.png)

模型现在是空的没关系；即使没有任何配置，我们也可以在下一节中使用它。

## 断言（Assertions）和集合（Sets）

Alice 的账号可以变成负数吗？现在我们的规范（spec）允许这样做，但这不是我们想要的。我们可以先在事务的后面添加一个简单的断言（assert）检查。这和其它语言中的断言（assert）一样。但在 TLA+ 中，它主要用于调试。这是因为 TLA+ 有更强大的工具：检查合约（checking contracts）和属性（properties）。但让我们从简单的开始。

下面是我们使用断言（assert）时代码的样子：

```tla+
---- MODULE transfer ----
EXTENDS Naturals, TLC

(* --algorithm transfer
variables alice_account = 10, bob_account = 10, money = 5;

begin
A: alice_account := alice_account - money;
B: bob_account := bob_account + money;
C: assert alice_account >= 0;
end algorithm *)
=====
```

单元测试（unit testing）和测试驱动开发（test-driven development）的一般做法：编写破坏测试，修复它，编写工作测试。如果我们运行这个，模型将成功通过。

至少，它适用于我们试过的一个数字。但这并不意味着它适用于所有情况。在测试时，通常很难选择正确的测试用例来显示您想要找到的 BUG。这是因为大多数语言都使测试特定的状态很容易，但测试一组特定的状态并不容易。然而，在 TLA+ 中，大范围测试很简单：

```tla+
---- MODULE transfer ----
EXTENDS Naturals, TLC

(* --algorithm transfer
variables alice_account = 10, bob_account = 10, money \in 1..20;

begin
A: alice_account := alice_account - money;
B: bob_account := bob_account + money;
C: assert alice_account >= 0;
end algorithm *)
=====
```

我们唯一的改变是把 `money = 5` 变成了 `money \in 1..20`。就像你可能已经想到的那样，在这个算法中，`money` 可以是 1 到 20 之间的任何数字。这意味着在检查模型时，有 20 种可能的开始状态：（10，10，1），（10，10，2）等等。TLA+ 将尝试所有 20 种可能性，看看是否有一种会破坏断言。这个可以扩展，如果我们中写成 `alice_account \in {5,10}`，将有 40 种可能的开始状态。

（`{}` 集合符号。`a..b` 是“a 和 b 之间所有整数的集合”的语法糖，所以 `1..3 = {1, 2, 3}`）

当我们运行这个的时候，我们会立即得到一个错误：

【图片】

我们可以通过 if-block 来解决这个问题：

```tla+
---- MODULE transfer ----
EXTENDS Naturals, TLC

(* --algorithm transfer
variables alice_account = 10, bob_account = 10, money \in 1..20;

begin
Transfer:
  if alice_account >= money then
    A: alice_account := alice_account - money;
    B: bob_account := bob_account + money;
end if;
C: assert alice_account >= 0;
end algorithm *)
=====
```

现在运行正常。

旁白：这是尽可能的测试所有可能的情况，但不是测试所有可能的情况。如果 `money` 是 4997，算法会崩溃吗？如果我们真的想测试所有可能的情况，可以用 `money \in Nat` 来替换 `money \in 1..20`，`Nat` 是自然数集合。这是完全有效的TLA+。不幸的是，这也是模型检查器无法处理的。TLC 只能检查 TLA+ 的一个子集，不包括无限集。

## TLA+ 和不变量（Invariants）

你能转负数的钱吗？我们可以在算法的开头添加一个 `assert money > 0`。不过，这一次，我们将介绍一种新方法，为下一节做准备。

```tla+
---- MODULE Transfer ----
EXTENDS Naturals, TLC

(* --algorithm transfer
variables alice_account = 10, bob_account = 10, money \in 1..20;

begin
Transfer:
  if alice_account >= money then
    A: alice_account := alice_account - money;
    B: bob_account := bob_account + money;
end if;
C: assert alice_account >= 0;

end algorithm *)

\* BEGIN TRANSLATION
\* Removed for clarity...
\* END TRANSLATION

MoneyNotNegative == money >= 0

====
```

在这里有一些事情要注意一下。首先，这不是 PlusCal 算法的一部分。我们将纯 TLA+ 放在文件的底部，以便能够被已转换的 TLA+ 引用。TLA+ 可以引用您的 PlusCal 可以引用的任何内容，只要它位于 `END TRANSLATION` 标记之后。其次，它不会改变任何事情。它只是系统的一个属性（property）。如果 `money` 是负的，`MoneyNotNegative` 就是 false，否则就是 true。属性（property）用 `==` 指定。

这与 `assert` 有何不同？断言检查在一个位置。我们可以指定 `MoneyNotNegative` 作为系统的一个不变量（Invariant），它在所有可能的系统状态下都必须为真。它成为了模型的一部分，然后它会在 Alice 的账户里取钱之前进行检查，包括存款和取款等等。如果我们在任何地方添加 `money := money - 2` 步骤，那么当 `money = 1` 时，`MoneyNotNegative` 不变量将捕捉到规范（spec）失败。

**注意**：如果模型抱怨 `MoneyInvariant` 是一个未知的操作，那么您可能已经将定义放在模块的末尾。记住，以==== 开头的第一行之后的所有内容都将被忽略！

## 更进一步：检查原子性

到目前为止，我们还没有做任何特殊的事情。到目前为止的任何事情在真实的系统中都很容易通过单元（unit）和性能（property）测试检查出来。
到目前为止，通过单元测试和属性测试可以很容易地覆盖实际系统中的所有内容。还有很多地方需要介绍，但我想说明的是，我们已经可以使用我们所学到的知识来发现更复杂的 BUG。Alice 想给 Bob 1000 美元。如果我们运气不好，结果可能是这样的：

1. 系统检查出 Alice 有这么多钱。
2. 从 Alice 账号中扣除 1000 美元。
3. Eve 用棒球棒打碎了服务器。
4. Bob 再也收不到这笔钱。
5. 1000 美元从系统中完全消失了。
6.  SEC 以欺诈罪将你的公司关闭。

我们已经有了全套的工具来检查这个。首先，我们需要弄清楚如何表示被破坏的不变量（invariant）。我们可以这样做，要求系统中的总钱数总是相同的：

```tla+
---- MODULE Transfer ----
EXTENDS Naturals, TLC

(* --algorithm transfer
variables alice_account = 10, bob_account = 10, money \in 1..20,
          account_total = alice_account + bob_account;

begin
Transfer:
  if alice_account >= money then
    A: alice_account := alice_account - money;
    B: bob_account := bob_account + money;
end if;
C: assert alice_account >= 0;

end algorithm *)

MoneyNotNegative == money >= 0
MoneyInvariant == alice_account + bob_account = account_total

====
```

然后，我们将选中的不变量声明给模型：

【图片】

【图片】

当我们运行这个时，TLC 发现了一个反例：在步骤 A 和步骤 B 之间，不变量（invariant）不成立。

【图片】

怎么解决这个问题呢？它取决于我们所关心的抽象级别。如果您正在设计一个数据库，您需要指定保持系统一致性所需的确切步骤。不过，在我们的级别上，我们可能可以访问数据库事务，并且可以“抽象”出原子性检查。我们的方法是将A和B合并到一个“事务”步骤中。这告诉 TLA+ 两个操作同时发生，并且系统永远不会通过无效状态。

```tla+
---- MODULE Transfer ----
EXTENDS Naturals, TLC

(* --algorithm transfer
variables alice_account = 10, bob_account = 10, money \in 1..20,
          account_total = alice_account + bob_account;

begin
Transfer:
  if alice_account >= money then
    A: alice_account := alice_account - money;
       bob_account := bob_account + money; \* Both now part of A
end if;
C: assert alice_account >= 0;

end algorithm *)

MoneyNotNegative == money >= 0
MoneyInvariant == alice_account + bob_account = account_total

====
```

## 多进程算法

作为示例的最后一部分，让我们讨论并发性。目前，我们的系统似乎足够稳定，可以在两方之间进行一次转账。但是，如果人们可以进行多次转账，会发生什么呢？每一个都使用相同的帐户状态，但彼此独立运行。我们能测试这个系统的行为吗？

PlusCal 支持多进程算法。进程可以是完全不同的算法同时发生，也可以是相同的算法同时发生(或者两者都发生)。后者是我们想要规范（spec）的。下面是如果我们可以做两个交易的样子：

```tla+
---- MODULE Transfer ----
EXTENDS Naturals, TLC

(* --algorithm transfer
variables alice_account = 10, bob_account = 10,
          account_total = alice_account + bob_account;

process Transfer \in 1..2
  variable money \in 1..20;
begin
Transfer:
  if alice_account >= money then
    A: alice_account := alice_account - money;
       bob_account := bob_account + money;
end if;
C: assert alice_account >= 0;
end process

end algorithm *)

MoneyNotNegative == money >= 0
MoneyInvariant == alice_account + bob_account = account_total

====
```

帐户是全局变量，而货币是过程的局部变量。这意味着有 400 种可能的初始状态，因为第一个转移可以是 1 美元，第二个是 7 美元。然而，实际上有 2400 种可能的行为！这是因为 TLC 可以选择运行流程的顺序，以及如何交错它们。
然而，`MoneyNotNegative` 不再有意义了，因为现在货币有两个值。如果你已经将其添加到模型中，请确保取消选中它，以避免出现错误并重新运行。您应该会得到以下错误：

【图片】

当我们检查 Alice 是否有足够的钱时和我们实际转账的时候是有差距的。在一个进程中，这不是问题，但在两个进程中，这意味着她的账户可以变为负数。TLC足以提供重现 BUG 所需的初始状态和步骤。

这个例子只涉及工具的一小部分；我们甚至还没有接触到时间属性、活动或设置操作。不过，希望这已经向您展示了，即使对 TLA+ 稍有了解也足以发现有趣的问题。

翻译自 [AN EXAMPLE](https://learntla.com/introduction/example/)
